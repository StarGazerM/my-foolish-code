// Yihao Sun(ysun67@syr.edu)
// 2019 in Syracuse

// the anderson style analysis for
// field sensitive, context-insensitive, flow insensitive
// https://www.cs.cmu.edu/~aldrich/courses/15-819O-13sp/resources/pointer.pdf
// https://yanniss.github.io/points-to-tutorial15.pdf

.symbol_type Var // Varible
.symbol_type Obj // using a fake number   simulate address 
// .symbol_type Sig // here signature is the function's name with it's args palce holder
.symbol_type Field  // the Field in an struct or Object 
.symbol_type Instr  // the Instr like a = new Foo()
.symbol_type Method // name of a Method, like Foo.id(), this should be unique
.number_type Position    // the postion of a arg
.symbol_type Class
//.type Instr = ALLOC | ASSIGN | STORE | VCALL

// input facts
// there should be two parts here
// 1. Instruction, 5types (ALLOC | ASSIGN | STORE | LOAD | VCALL)
//    STORE and LOAD is because we want some field sensitive info
// 2. relation reps name (I ignore type here)
.decl Alloc(v: Var, o: Obj, in:Method)  // v = new O(); and in is in where it calls this ∈ Var v
.decl Assign(to: Var, from: Var)            // to = from;  v1 ⊇ v2
.decl Load(to: Var, target: Var, f: Field)  // to = target.f
.decl Store(target: Var, f: Field, from: Var)   // target.f = from
.decl Vcall(target: Var, fun: Method, ins: Instr, inM:Method)    // inside some Method "in", target.fun()
                                                                // ins is the full call line code
.decl ThisCall(fun: Method, ins: Instr, inM:Method)   // some direct call like foo(); or this.foo(); 

// some info relate to name
.decl FormalArg(m: Method, pos: Position, arg: Var) // formal arg inside a Method m, pos is a mark 
                                                    // to identify which arg it is
.decl RealArg(i: Instr, pos: Position, arg: Var)    // i is from where a function is called
.decl FormalRet(m: Method, ret: Var)                // the formal return of a function
.decl RealRet(i: Instr, ret: Var)                   // in which Instr the value is returned to
.decl ClassOf(o: Obj, c: Class)                  // we need to denote the Class of a o is c 
.decl MethodOf(c: Class, m: Method)       // the signature of a Method is c and it's Class is c
.decl MemberOf(v: Var, c: Class)                    // denote the memeber varible in class

// input form file
.input Alloc
.input Assign
.input Load
.input Store
.input Vcall
.input ThisCall
.input FormalArg
.input RealArg
.input FormalRet
.input RealRet
.input ClassOf
.input MethodOf
.input MemberOf

// .decl InstrInMeth(ins: Instr, c: Class)

// our target
// here duplicated name of function is not allowed
// no polymophism, subtyping

// Class A1() {
//     var some;
//     var other;
//     setSome(s) { some = s; }
//     getSome() { return some; }
// }
// Class B1() {}
// Class Main {
//     Main () {
//         fun1();
//     }
//     fun1() {
//         var a1 = new A1();
//         var b1 = new B1(); 
//         var c1 = new B1();
//         a1.setSome(b1);
//         a1.other = b1;
//         c1 = a1.getSome();
//         c1 = a1.other;
//     }
//     print(Object m){ /*some io here*/ }
// }

// derived input facts
// Alloc("$Main", "oMain", "$init"). // the dummy main generated by dummy init
// // assume every ALLOC will allocate an object called "o$" to an var
// Alloc("a1", "o1", "fun1").
// Alloc("b1", "o2", "fun1").
// Alloc("c1", "o3", "fun1").
// Assign("some", "s").
// Load("c1", "a1", "other").
// Store("a1", "other", "b1").
// ThisCall("fun1", "{fun1();}", "Main").
// Vcall("a1", "setSome", "{a1.setSome(b1);}", "fun1").
// Vcall("a1", "getSome", "{c1 = a1.getSome();}", "fun1").
// FormalArg("setSome", 0, "s").
// FormalArg("Main.print", 0, "m").
// RealArg("{a1.setSome(b1);}", 0, "b1").
// FormalRet("getSome", "some").
// RealRet("{c1 = a1.getSome();}", "c1").
// ClassOf("oMain", "Main").
// ClassOf("o1", "A1").
// ClassOf("o2", "B1").
// ClassOf("o3", "B1").
// MethodOf("A1", "setSome").
// MethodOf("A1", "getSome").
// MethodOf("Main", "fun1").
// MethodOf("Main", "print").
// MethodOf("Main", "Main").
// MemberOf("some", "A1").
// MemberOf("other", "A1").
// here for convience I omit InsInMethod facts to instr is in which method

// output relation
// where a var is point to
.decl VarPointTo(v: Var, o: Obj)
.output VarPointTo
// alloc
VarPointTo(v, o) :- Reachable(m), Alloc(v, o, m).
// assign
VarPointTo(to, o) :- Assign(to, from), VarPointTo(from, o).
// field
VarPointTo(to, o) :- 
    Load(to, targetV, f), 
    VarPointTo(targetV, targetO), FieldPointsTo(targetO, f, o).
// return and pass arg
VarPointTo(to, o) :-
    InterProcAssign(to, from), VarPointTo(from, o).

// where a field of a object point to another object(just like a var can point to)
.decl FieldPointsTo(target: Obj, f: Field, to: Obj)
.output FieldPointsTo
FieldPointsTo(targetO, f, to) :- 
    Store(targetV, f, from), 
    VarPointTo(from, to), VarPointTo(targetV, targetO).

// what method is reached
.decl Reachable(m: Method)
.output Reachable
// dummy main is always reachable
Reachable("Main").
// if a method is in call CallGraph then it is valid and reachable
Reachable(m) :- 
    CallGraph(_, m).

// On-the-fly call-graph
// if a vcall is made on varible *target* and if this target is already
// allocated a heap space, meanwhile this heap's class do has this function
// then a edge will be add to call graph
.decl CallGraph(i: Instr, m: Method)
.output CallGraph
// vcall
CallGraph(i, toM) :-
    Vcall(targetV, toM, i, inM), 
    Reachable(inM),
    VarPointTo(targetV, targetO),
    ClassOf(targetO, clazz),
    MethodOf(clazz, toM).
// this call
CallGraph(i, toM) :-
    ThisCall(toM, i, inM),
    Reachable(inM),
    MethodOf(clazz, inM),
    MethodOf(clazz, toM).

// meanwhile, we should also notice that, a call of fucntion may cause args
// pass and value return, this should also be viewed as a assign instruction
.decl InterProcAssign(to: Var, from: Var)
.output InterProcAssign
InterProcAssign(to, from) :- 
    CallGraph(i, m),
    FormalArg(m, pos, to), RealArg(i, pos, from).

InterProcAssign(to, from) :-
    CallGraph(i, m),
    FormalRet(m, from), RealRet(i, to).
