;; a little scheme parser
;; in next step this file should be able to auto generated by grammar file
;; code here can be ugly, I just want to show this can be done by some code gen

#lang racket

(provide (all-defined-out))

;; AST
(define (ast? a)
  (match a
    ;; non-term
    [`(,(? symbol? type) (,(? ast? leaf) ...)) #t]
    ;; term
    [`(%TERM ,x) #t]
    [else #f]))

(define (scheme-term? st)
  (member st '(LP RP LB RB lambda T F let and or not cons if define quote eqv?
                  equal? car cdr apply eval + - * / exit garbage-collect
                  print integer? float? number? string? symbol? list?
                  procedure? boolean? closure? while set! > < )))

(define (scheme-nonterm? snt)
  (member snt '(NAME VAR PRIM DATUM FUN DEF IF APP APP_PRIM AEXPR LET_BIND LET CEXPR EXPR PROG)))

(define (term->ast t)
  (match t
    [(? scheme-term?) `(%TERM ,t)]))

(define (prim? p)
  (member p '(eqv? and or not cons 
                 equal? car cdr apply eval + - * / exit garbage-collect
                 print integer? float? number? string? symbol? list?
                 procedure? boolean? closure? while set! > < )))

(define (prim->ast p)
  `(PRIM ((%TERM ,p))))

(define (datum? d)
  (match d
    [`(quote ,(? (or/c expr? aexpr?))) #t]
    [else #f]))

(define (datum->ast d)
  (match d
    [`(quote ,(? aexpr? d))
     `(DATUM ((%TERM quote) (AEXPR ,d)))]
    [`(quote ,(? expr? d))
     `(DATUM ((%TERM quote) (EXPR ,d)))]))

(define (fun? f)
  (match f
    [`(lambda (,(? symbol?) ...) ,(? expr?)) #t]
    [else #f]))

(define (fun->ast f)
  (match f
    [`(lambda (,(? symbol? vars) ...) ,(? expr? body))
     `(FUN ((%TERM lambda) ,@(map term->ast vars) ,(expr->ast body)))]))

(define (def? fd)
  (match fd
    [`(define (,(? symbol?) ,(? symbol?) ...) ,(? expr?)) #t]
    [`(define ,(? symbol?) ,(? expr?)) #t]
    [else #f]))

(define (def->ast fd)
  (match fd
    [`(define (,(? symbol? fun-name) ,(? symbol? args) ...) ,(? expr? body))
     `(DEF ((%TERM define) (%TERM fun-name) ,@(map term->ast args) ,(expr->ast body)))]
    [`(define ,(? symbol? name) ,(? expr? body))
     `(DEF ((%TERM define) (%TERM ,name) (expr->ast body)))]))

(define (if? i)
  (match i
    [`(if ,(? expr?) ,(? expr?) ,(? expr?)) #t]
    [else #f]))

(define (if->ast i)
  (match i
    [`(if ,(? expr? eguard) ,(? expr? et) ,(? expr? ef))
     `(IF ((%TERM if) ,(expr->ast eguard) ,(expr->ast et) ,(expr->ast ef)))]))

(define (app? a)
  (match a
    [`(,(? (or/c cexpr? fun? symbol?)) ,(? expr?) ...) #t]
    [else #f]))

(define (app->ast a)
  (match a
    [`(,(? fun? f) ,(? expr? as) ...)
     `(APP (,(fun->ast f) ,@(map expr->ast as)))]
    [`(,(? cexpr? f) ,(? expr? as))
     `(APP (,(cexpr->ast f) ,@(map expr->ast as)))]))

(define (app-prim? a)
  (match a
    [`(,(? prim?) ,(? expr?) ...) #t]
    [else #f]))

(define (app-prim->ast a)
  (match a
    [`(,(? prim? p) ,(? expr? as) ...)
     `(APP_PRIM (,(prim->ast p) ,@(map expr->ast as)))]))

(define (aexpr? a)
  (match a
    [(? fun?) #t]
    [(? symbol?) #t]
    [(? number?) #t]
    [(? boolean?) #t]
    [(? prim?) #t]
    [(? datum?) #t]
    [else #f]))

(define (aexpr->ast a)
  (match a
    [(? fun?) `(AEXPR (,(fun->ast a)))]
    [(? symbol?) `(AEXPR (,(term->ast a)))]
    [(? number?) `(AEXPR (,(term->ast a)))]
    [(? boolean?) `(AEXPR (,(term->ast a)))]
    [(? prim?) `(AEXPR (,(prim->ast a)))]
    [(? datum?) `(AEXPR `(AEXPR (,(datum->ast a))))]))

(define (let-bind? lb)
  (match lb
    [`(,(? symbol?) ,(? expr?)) #t]
    [else #f]))

(define (let-bind->ast lb)
  (match lb
    [`(,(? symbol? n) ,(? expr? b))
     `( LET_BIND ((%TERM ,n) ,(expr->ast b)))]))

(define (let? l)
  (match l
    [`(let (,(? let-bind?) ...) ,(? expr?)) #t]
    [else #f]))

(define (let->ast l)
  (match l
    [`(let (,(? let-bind? lbs) ...) ,(? expr? body))
     `(LET ((%TERM let) ,@(map let-bind->ast lbs) ,(expr->ast body)))]))

(define (cexpr? c)
  (match c
    [(? app?) #t]
    [(? let?) #t]
    [(? app-prim?) #t]
    [else #f]))

(define (cexpr->ast c)
  (match c
    [(? app?) `(CEXPR ,(app->ast c))]
    [(? let?) `(CEXPR ,(let->ast c))]
    [(? app-prim?) `(CEXPR ,(app-prim->ast c))]))

(define (expr? e)
  (match e
    [(? cexpr?) #t]
    [(? aexpr?) #t]
    [else #f]))

(define (expr->ast e)
  (match e
    [(? cexpr?) `(EXPR ,(cexpr->ast e))]
    [(? aexpr?) `(EXPR ,(aexpr->ast e))]))

(define (prog? p)
  (match p
    [`(,(? (or/c cexpr? def?)) ...) #t]
    [else #f]))

(define (prog->ast p)
  (match p
    [`(,(? (or/c cexpr? def?) ss) ...)
     `(PROG ,(map (Î» (s)
                    (match s
                      [(? cexpr?) (cexpr->ast s)]
                      [(? def?) (def->ast s)]))
                  ss))]))

